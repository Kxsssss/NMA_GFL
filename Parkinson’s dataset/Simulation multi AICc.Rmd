
```{r}
simulti_p_aicc <- function(X, bb, fac){
  ### e
  # generate 1000 epsilon
  size = 1000                                      
  meanvector = rep(0, nrow(X))                                 
  # matrix with all var on diagonal
  var_cov = diag((pksn_multi$seTE*fac)^2)
  # find the indexes that stands for multi-arm 
  multi_index = which(pksn_multi$studlab == unique(as.vector(p_study$studlab)))
  # update the cov terms in the var_cov matrix 
  var_cov[multi_index[1],multi_index[2]] = cov_Guttman1997 * (fac^2)
  var_cov[multi_index[2],multi_index[1]] = cov_Guttman1997 * (fac^2)
  e <- mvrnorm(n = size, mu = meanvector, Sigma = var_cov)
  
  ### y
  y_ = matrix(rep(as.numeric(X %*% bb), 1000), ncol = nrow(X), byrow=TRUE) + e
  
  sim_sum = data.frame()
  for (i in 1:1000) {
    y = y_[i,]
    n = length(y)
    K = ncol(X)
    # Choleski Decomposition of var_cov matrix
    w = chol(solve(var_cov))
    gr <- graph(c(1,2,1,3,1,4,2,3,2,4,3,4), directed=FALSE)
    fit = fusedlasso(y=w%*%y, X=w%*%X, graph = gr, gamma=1)
    # fusedLasso_gr(fit) (graph code)
    
    ### df, lambda, rss, AICc
    rss = summary(fit)[,3]
    Ks = summary(fit)[,1]
    beta = fit$beta[, best_row(rss, Ks, n)]
    # Calculate the rss for the full model 
    mod = glm(w%*%y ~ w%*%X - 1)
    rss_full = deviance(mod)
    # update variables 
    rss = c(rss, rss_full)
    Ks = c(Ks, K)
    # adding the full model to the summary
    sum_table = rbind(summary(fit), c(K, 0, rss_full))
    # Add corresponding AICc values into the table 
    sum_table_a = data.frame(cbind(sum_table, AICc = AICc_rss(rss, Ks, n)))
    rownames(sum_table_a) = 1:nrow(sum_table_a)
    
    
    # based on each case, give the correct df
    #   (0,0,0,0), all same, correct df = 0
    #   (0.5,1,3,5), all diff, correct df = 4
    #   (1,1,-2,-2), correct df = 2
    #   (1,1,1,-2), correct df = 1
    if (all(bb == rep(0, 4))){correct_df = 0}
    if (all(bb == c(0.5,1,3,5))){correct_df = 4}
    if (all(bb == c(1,1,-2,-2))){correct_df = 2}
    if (all(bb == c(1,1,1,-2))){correct_df = 2}
    
    #### delta_AIC 
    #   (the difference between the correct model and the selected one)
    # if df = 0 gives the smallest AICc, then only the smallest lambda is added
    select_index = max(which(sum_table_a$AICc == min(sum_table_a$AICc)))
    select = sum_table_a[select_index,]
    # under the correct df, find the one that has the smallest AICc 
    df_index = which(sum_table_a$df == correct_df)
    df_rows = sum_table_a[df_index,]
    correct = df_rows[max(which(df_rows$AICc == min(df_rows$AICc))),]
    delta_AICc = abs(select$AICc - correct$AICc)
    
    #### Path check
    # based on each case, give the correct pooling pairs
    if (all(bb == c(0.5,1,3,5))){cpair = c()}
    if (all(bb == c(1,1,-2,-2))){cpair = c(23, 45)}
    if (all(bb == c(1,1,1,-2))){cpair = c(23, 24, 34)}
    # under correct df, see if there exist a model that has correct path
    # path indicator (path_indicator) is set to be no as default
    path_indicator = "no"
    if (correct_df == 0 | correct_df == 4){path_indicator = "yes"}
    # (1,1,-2,-2)
    if (all(bb == c(1,1,-2,-2))){
      j = 1
      while (path_indicator == "no" & j <= length(df_index)) {
        pool_pairs_model = pairwise_pool_names(df_index[j], fit)
        #print(i)
        #print(pool_pairs_model)
        if (length(pool_pairs_model) == 2){
          if (all(pool_pairs_model == cpair)){path_indicator = "yes"}
        }
        j = j + 1
      }
    }
    # (1,1,1,-2)
    if (all(bb == c(1,1,1,-2))){
      j = 1
      while (path_indicator == "no" & j <= length(df_index)) {
        pool_pairs_model = pairwise_pool_names(df_index[j], fit)
        #print(i)
        #print(pool_pairs_model)
        if (length(pool_pairs_model) == 3){
          if (all(pool_pairs_model == cpair)){path_indicator = "yes"}
        }
        j = j + 1
      }
    }
    
    
    ### false pooling within the best model 
    pair_values = rep(0, 10)
    names = c(12, 13, 14, 15, 23, 24, 25, 34, 35, 45)
    pool_best = pairwise_pool_names(select_index, fit)
    # indicator of FP, default is no, which means no FP
    best_indicator = "no"
    if (correct_df == 0){
      best_indicator = "no"
    }else if (correct_df == 4){
      if (!is.null(pool_best)){best_indicator = "yes"}
      }else{
      ss = append(cpair, pool_best)
      # if further pooling are there compared to the correct pairs
      if (length(unique(ss)) > length(cpair)) {best_indicator = "yes"}
    }
    # update 1-2 1-3 1-4 1-5 2-3 2-4 2-5 3-4 3-5 4-5
    for (k in pool_best){
        pair_values[which(names == k)] = 1
    }
    pair_values = matrix(pair_values, nrow = 1)
    
    
    
    ### (estimated dd - true dd)^2 for best model and full model 
    # true values 
    true_dd = gene_dd(bb)
    # full model 
    esti_full = gene_dd(as.vector(coef(mod)))
    full_diff2 = matrix((true_dd - esti_full)^2, nrow = 1)
    # best model 
    if (select_index == nrow(sum_table_a)){ #full model is selected
      best_diff2 = full_diff2
    }else{
      esti_best = gene_dd(fit$beta[,select_index])
      best_diff2 = matrix((true_dd - esti_best)^2, nrow = 1)
    }
    
    
    
    # add the row that has the smallest AICc values into the summary table
    sim_sum = rbind(sim_sum, 
                    cbind(select, correct, delta_AICc, path_indicator, 
                          best_indicator, pair_values, full_diff2, best_diff2))
    if(i%%200==0){print(i)}
  }
  rownames(sim_sum) = 1:nrow(sim_sum)
  colnames(sim_sum)[c(1, 5)] = c("select_df", "correct_df")
  colnames(sim_sum)[c(12:21)] = c("1-2_poll","1-3", "1-4", "1-5", "2-3", "2-4",
                                  "2-5", "3-4", "3-5", "4-5_poll")
  colnames(sim_sum)[c(22:31)] = c("1-2_full","1-3", "1-4", "1-5", "2-3", "2-4",
                                  "2-5", "3-4", "3-5", "4-5_full")
  colnames(sim_sum)[c(32:41)] = c("1-2_best","1-3", "1-4", "1-5", "2-3", "2-4",
                                  "2-5", "3-4", "3-5", "4-5_best")
  
   
  sim_sum
}
```


```{r}
rm(list = ls())
```


```{r}
# To load the data again
load("Sim.RData")
```

```{r}
data(Franchini2012) # Transform data from arm-based format to contrast-based format 
p1 <- pairwise(list(Treatment1, Treatment2, Treatment3), n = list(n1, n2, n3), mean = list(y1, y2, y3), sd = list(sd1, sd2, sd3), data = Franchini2012, studlab = Study) 
p_study = multi_study(p1)

cov_Guttman1997 = (0.6990666^2 + 0.6949881^2 - 0.7177460^2)/2

pksn_multi = p1[-3, 1:5]
```



# (0,0,0,0,0)
```{r}
bb = rep(0, 4)
X = X_matrix(pksn_multi$treat1, pksn_multi$treat2, ref = "Placebo", n = 5)
set.seed(1)
sim_sum0_0.1_a = simulti_p_aicc(X, bb, 0.1)
sim_sum0_1_a = simulti_p_aicc(X, bb, 1)
sim_sum0_10_a = simulti_p_aicc(X, bb, 10)
```

```{r}
ps01a = prob_sum(sim_sum0_0.1_a)
ps02a = prob_sum(sim_sum0_1_a)
ps03a = prob_sum(sim_sum0_10_a)
ps01a
ps02a 
ps03a
```






# (0,0.5,1,3,5)
```{r}
bb1 = c(0.5, 1, 3, 5)
X = X_matrix(pksn_multi$treat1, pksn_multi$treat2, ref = "Placebo", 
              n = 5)
set.seed(1)
sim_sum1_0.1a = simulti_p_aicc(X, bb1, 0.1)
sim_sum1_1a = simulti_p_aicc(X, bb1, 1)
sim_sum1_10a = simulti_p_aicc(X, bb1, 10)
```

```{r}
ps11a = prob_sum(sim_sum1_0.1a)
ps12a = prob_sum(sim_sum1_1a)
ps13a = prob_sum(sim_sum1_10a)
ps11a
ps12a
ps13a
```





# (0,1,1,-2,-2)
```{r}
bb2 = c(1,1,-2,-2)
X = X =  X_matrix(pksn_multi$treat1, pksn_multi$treat2, ref = "Placebo", 
              n = 5)
set.seed(1)
sim_sum2_0.1a = simulti_p_aicc(X, bb2, 0.1)
sim_sum2_1a = simulti_p_aicc(X, bb2, 1)
sim_sum2_10a = simulti_p_aicc(X, bb2, 10)
```

```{r}
ps21a = prob_sum(sim_sum2_0.1a)
ps22a = prob_sum(sim_sum2_1a)
ps23a = prob_sum(sim_sum2_10a)

ps21a
ps22a
ps23a
```






# (0,1,1,1,-2)
```{r}
bb3 = c(1,1,1,-2)
X = X =  X_matrix(pksn_multi$treat1, pksn_multi$treat2, ref = "Placebo", 
              n = 5)
set.seed(1)
sim_sum3_0.1a = simulti_p_aicc(X, bb3, 0.1)
sim_sum3_1a = simulti_p_aicc(X, bb3, 1)
sim_sum3_10a = simulti_p_aicc(X, bb3, 10)
```

```{r}
ps31a = prob_sum(sim_sum3_0.1a)
ps32a = prob_sum(sim_sum3_1a)
ps33a = prob_sum(sim_sum3_10a)
ps31a
ps32a
ps33a
```

```{r}
# select 'yes' path check for all 12 categories
graph_t = data.frame(rbind(cbind(delta_AICc = sim_sum0_0.1_a$delta_AICc, 
                                 group = rep("(0,0,0,0) & 0.1", 1000)),
                cbind(delta_AICc = sim_sum0_1_a$delta_AICc, group = rep("(0,0,0,0) & 1", 1000)),
                cbind(delta_AICc = sim_sum0_10_a$delta_AICc, group = rep("(0,0,0,0) & 10", 1000)),
                cbind(delta_AICc = sim_sum1_0.1a$delta_AICc, group = rep("(0.5,1,3,5) & 0.1", 1000)),
                cbind(delta_AICc = sim_sum1_1a$delta_AICc, group = rep("(0.5,1,3,5) & 1", 1000)),
                cbind(delta_AICc = sim_sum1_10a$delta_AICc, group = rep("(0.5,1,3,5) & 10", 1000))))

# (1,1,-2,-2) (1,1,1,-2)
s201 = which(sim_sum2_0.1a$path_indicator == "yes")
s21 = which(sim_sum2_1a$path_indicator == "yes")
s210 = which(sim_sum2_10a$path_indicator == "yes")
s301 = which(sim_sum3_0.1a$path_indicator == "yes")
s31 = which(sim_sum3_1a$path_indicator == "yes")
s310 = which(sim_sum3_10a$path_indicator == "yes")

graph_t = rbind(graph_t, 
                cbind(delta_AICc = sim_sum2_0.1a[s201,]$delta_AICc, 
                      group = rep("(1,1,-2,-2) & 0.1", length(s201))),
                cbind(delta_AICc = sim_sum2_1a[s21,]$delta_AICc, 
                      group = rep("(1,1,-2,-2) & 1", length(s21))),
                cbind(delta_AICc = sim_sum2_10a[s210,]$delta_AICc, 
                      group = rep("(1,1,-2,-2) & 10", length(s210))),
                cbind(delta_AICc = sim_sum3_0.1a[s301,]$delta_AICc, 
                      group = rep("(1,1,1,-2) & 0.1", length(s301))),
                cbind(delta_AICc = sim_sum3_1a[s31,]$delta_AICc, 
                      group = rep("(1,1,1,-2) & 1", length(s31))),
                cbind(delta_AICc = sim_sum3_10a[s310,]$delta_AICc, 
                      group = rep("(1,1,1,-2) & 10", length(s310))))

graph_t$interval = rep(1, nrow(graph_t))
graph_t$delta_AICc = as.numeric(graph_t$delta_AICc)
for (i in 1:nrow(graph_t)) {
  if(graph_t[i,]$delta_AICc == 0){graph_t[i, ]$interval = "0"} else
    if(0 < abs(graph_t[i,]$delta_AICc) & abs(graph_t[i,]$delta_AICc) <= 2){
      graph_t[i,]$interval = "0-2"
      } else if(2 < abs(graph_t[i,]$delta_AICc) & abs(graph_t[i,]$delta_AICc) <= 4){
        graph_t[i,]$interval = "2-4"
        }else if(4 < abs(graph_t[i,]$delta_AICc) & abs(graph_t[i,]$delta_AICc) <= 7){
          graph_t[i,]$interval = "4-7"
          }else if(7 < abs(graph_t[i,]$delta_AICc) & abs(graph_t[i,]$delta_AICc) <= 10){
            graph_t[i,]$interval = "7-10"
            }else{
              graph_t[i,]$interval = ">10"
              }
}
graph_t$group = as.factor(graph_t$group)
graph_t$interval = as.factor(graph_t$interval )
```

```{r}
library(dplyr)
plotdata <- graph_t %>%
  group_by(group, interval) %>%
  summarize(n = n()) %>% 
  mutate(pct = n/sum(n),
         lbl = scales::percent(pct, digits = 1))
plotdata
```

```{r}
library(ggplot2)
ggplot(plotdata, 
       aes(x = factor(group,
                      levels = levels(graph_t$group)),
           y = pct,
           fill = factor(interval, 
                         levels = c("0", "0-2", "2-4", "4-7", "7-10", ">10"),
                         labels = paste0('|delta AICc| ', 
                                         c( "= 0", "in (0, 2]", "in (2, 4]", "in (4, 7]",
                                            "in (7, 10]", "> 10")) ))) + 
  geom_bar(stat = "identity",
           position = "fill") +
  scale_y_continuous(breaks = seq(0, 1, .2), 
                     label = percent) +
  geom_text(aes(label = lbl), 
            size = 3, 
            position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette = "Set2") +
  labs(y = "Percent", 
       fill = "Intervals:",
       x = "Group of d' with multiplier") +
  theme_minimal() +
  theme(legend.position="top", 
        axis.text.x = element_text(angle = 90, size=12),
        axis.title.y = element_text(size = 12))
```



```{r}
par(mfrow=c(3,4))
dat_list = list(sim_sum0_0.1_a, sim_sum1_0.1a, sim_sum2_0.1a, sim_sum3_0.1a,
                sim_sum0_1_a, sim_sum1_1a, sim_sum2_1a, sim_sum3_1a,
                sim_sum0_10_a, sim_sum1_10a, sim_sum2_10a, sim_sum3_10a)
dat_titles = c("(0,0,0,0) & 0.1", "(0.5,1,3,5) & 0.1", "(1,1,-2,-2) & 0.1", "(1,1,1,-2) & 0.1", 
               "(0,0,0,0) & 1", "(0.5,1,3,5) & 1", "(1,1,-2,-2) & 1", "(1,1,1,-2) & 1",
               "(0,0,0,0) & 10", "(0.5,1,3,5) & 10", "(1,1,-2,-2) & 10", "(1,1,1,-2) & 10")

mse_t = data.frame()

for (i in 1:length(dat_list)){
  mse_full = apply(dat_list[[i]][22:31], 2, sum)/1000
  mse_best = apply(dat_list[[i]][32:41], 2, sum)/1000
  tit = dat_titles[i]
  
  mse_t = rbind(mse_t, cbind(tit, matrix(round(mse_full, 4), nrow = 1)))
  mse_t = rbind(mse_t, cbind(tit = "", matrix(round(mse_best, 4), nrow = 1)))
  
  if(i<=4){
    plot(mse_full, mse_best, xlab = "MSE of Full Model", ylab = "MSE of Best Model",
         xlim=c(0, 0.004), 
         ylim=c(0, 0.004))
  }else if(i<=8){
    plot(mse_full, mse_best, xlab = "MSE of Full Model", ylab = "MSE of Best Model",
         xlim=c(0, 0.75), 
         ylim=c(0, 0.75))
  }else{
    plot(mse_full, mse_best, xlab = "MSE of Full Model", ylab = "MSE of Best Model",
         xlim=c(0, 32), 
         ylim=c(0, 32))
  }
  title(paste(tit))
  abline(0,1, col = "red")
}

colnames(mse_t)[c(2:11)] = c("1-2","1-3", "1-4", "1-5", "2-3",
                             "2-4", "2-5", "3-4", "3-5", "4-5")

```











```{r}
# Save multiple objects
save(sim_sum0_0.1_a, sim_sum0_1_a,sim_sum0_10_a, ps01a, ps02a, ps03a,
     sim_sum1_0.1a, sim_sum1_1a,sim_sum1_10a, ps11a, ps12a, ps13a,
     sim_sum2_0.1a, sim_sum2_1a,sim_sum2_10a, ps21a, ps22a, ps23a,
     sim_sum3_0.1a, sim_sum3_1a,sim_sum3_10a, ps31a, ps32a, ps33a,
     graph_t, file = "Sim.RData")
```




